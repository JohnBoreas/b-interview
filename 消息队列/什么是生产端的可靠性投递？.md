什么是生产端的可靠性投递？

1. 保证消息的成功发出
2. 保证MQ节点节点的成功接收
3. 发送端MQ节点（broker）收到消息确认应答
4. 完善消息进行补偿机制





在高并发场景下，每次进行db的操作都是每场消耗性能的。我们使用延迟队列来减少一次数据库的操作。



高并发的情况下如何避免消息重复消费

1. 唯一id+加指纹码，利用数据库主键去重。优点：实现简单缺点：高并发下有数据写入瓶颈。
2. 利用Redis的原子性来实习。使用Redis进行幂等是需要考虑的问题

- 是否进行数据库落库，落库后数据和缓存如何做到保证幂等（Redis 和数据库如何同时成功同时失败）？
- 如果不进行落库，都放在Redis中如何这是Redis和数据库的同步策略？还有放在缓存中就能百分之百的成功吗？



消费端限流

rabbitMQ提供了一种qos（服务质量保证）的功能，即非自动确认消息的前提下，如果有一定数目的消息（通过consumer或者Channel设置qos）未被确认，不进行新的消费。

```
void basicQOS(unit prefetchSize,ushort prefetchCount,Boolean global)
```



消息变为死信的几种情况：

1. 消息被拒绝（basic.reject/basic.nack）同时requeue=false（不重回队列）
2. TTL过期
3. 队列达到最大长度