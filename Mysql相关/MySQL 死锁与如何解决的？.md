#### MySQL 遇到过死锁问题吗，你是如何解决的？





死锁的四个条件：

1、互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放
2、请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
3、不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4、循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞



产生death lock原理

insert ... on duplicate key 在执行时，innodb引擎会先判断插入的行是否产生重复key错误，如果存在，在对该现有的行加上S（共享锁）锁，如果返回该行数据给mysql,然后mysql执行完duplicate后的update操作，然后对该记录加上X（排他锁），最后进行update写入。



批处理死锁：

更新数据的时候，其中有部分数据锁加不上去，只能等待，就发生了阻塞

如果A进程阻塞了B，B又阻塞了A，就变成了死锁，估计有至少2个进程，同时在更新同一批数据，才会发生这种情况

同一批数据里要是2条相同的数据也会出现这种情况，因为会去更新同一条数据，一般来说会等待，超时就被牺牲掉了，或者运气不好升级为死锁，也可能被牺牲掉