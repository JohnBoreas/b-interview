

##### Redis如何做分布式锁？

答：



假设有两个服务A、B都希望获得锁，执行过程大致如下:

Step1： 服务A为了获得锁，向Redis发起如下命令: SET productId:lock 0xx9p03001 NX EX 30000 其中，"productId"由自己定义，可以是与本次业务有关的id，"0xx9p03001"是一串随机值，必须保证全局唯一，“NX"指的是当且仅当key(也就是案例中的"productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。"EX 30000"指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。

Step2: 服务B为了获得锁，向Redis发起同样的命令: SET productId:lock 0000111 NX  EX 30000
由于Redis内已经存在同名key，且并未过期，因此命令执行失败，服务B未能获得锁。服务B进入循环请求状态，比如每隔1秒钟(自行设置)向Redis发送请求，直到执行成功并获得锁。

Step3: 服务A的业务代码执行时长超过了30秒，导致key超时，因此Redis自动删除了key。此时服务B再次发送命令执行成功，假设本次请求中设置的value值为0000222。此时需要在服务A中对key进行续期，watch dog。

Step4: 服务A执行完毕，为了释放锁，服务A会主动向Redis发起删除key的请求。注意: 在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。比如当前场景下，Redis中的锁早就不是服务A持有的那一把了，而是由服务2创建，如果贸然使用服务A持有的key来删除锁，则会误将服务2的锁释放掉。此外，由于删除锁时涉及到一系列判断逻辑，因此一般使用lua脚本，具体如下:

```sql
if redis.call("get", KEYS[1])==ARGV[1] then
	return redis.call("del", KEYS[1])
else
	return 0
end
```





问题：

1）SET...NX 占好位，业务代码异常或者程序在⻚⾯过程中宕机，没有执⾏删除锁逻辑，这就造成了死锁！

解决：设置锁的⾃动过期时间，即使没有删除，会⾃动删除

2）SET...NX设置好，正要去设置过期时间，此时宕机，那就⼜会死锁

解决：设置过期时间和占位必须是原⼦的，**redis⽀持使⽤SET...EX 300 NX命令**

3）删除锁直接删除？如果由于业务时间⻓，锁⾃⼰过期了，我们直接删除，有可能把别⼈正在持有的锁删除了。

解决：**加锁的时候，值指定为UUID**，每个⼈匹配⾃⼰的锁才能删除。

4）删锁时，如果正好判断是当前的值，正要删除锁的时候，锁已经过期，别⼈已经设置到新的值，那么我们删除的是别⼈的锁。

解决：删除锁必须保证原⼦性，使⽤**Redis+Lua脚本**完成

5）、自动续期问题（可重入锁），就是业务处理时间过长，锁过期自动释放了

解决：使用**看门狗机制**，时间快到时候自动续期（后台启动一个**定时器任务，自动续期**，锁删除，定时器也跟着没有）

6）单点故障，引入主从，加锁的机器挂了，但是数据没有同步到另外的机器

解决：采用Red Lock，**部署奇数个机器，对所有机器加锁**，加锁过半成功则成功【牺牲部分性能保证一致】

使用Red Lock需要**延迟启动Redis**，否则会导致Redis（数据空白）重启后，其他业务加锁成功

7）由于Full GC 导致stop the world停顿，看门狗不工作，这时候无法续期，key过期了，其他业务加锁成功

解决：鸵鸟算法，

1、将redis换成zk（stop the world停顿也会导致jvm与zk的心跳连接中断，zk的临时节点失效）

2、在写zk时候返回zk的序列号，存入mysql的version字段，

3、每次修改数据代入where version = ？条件，如果序列号变化，就说明已经修改过，程序不在继续