在修饰方法的时候，默认是当前对象做为锁的对象

在修饰类时，默认是当前类的Class对象做为所的对象

故存在着方法锁、对象锁、类锁 这样的概念



#### 方法锁（synchronized修饰方法时）

每一个类实例对应一把锁

每一个synchronized方法都必须得到调用该方法的类实例的”锁“方能执行，不然所属线程阻塞。.net

​		方法一旦执行，就会独占该锁，一直到从该方法返回时才将锁释放，此后被阻塞的线程方能得到该锁，从而从新进入可执行状态。



#### 对象锁（synchronized修饰方法或代码块）

当一个对象中有synchronized method 或synchronized block 的时候，调用此对象的同步方法或进入其同步区域时，就必须先得到对象锁。

若是此对象的对象锁已被其余调用者占用，则须要等待此锁被释放。（方法锁也是对象锁）



#### 类锁（synchronized修饰静态的方法或者代码块）

因为一个class不论被实例化多少次，**其中的静态方法和静态变量在内存中都只有一份**。因此，一旦一个静态的方法被声明为synchronized。此类全部的实例对象在调用此方法，共用同一把锁，咱们称之为类锁。





 **前方高能：重点：要考的哦**

**对象锁是用来控制实例方法之间的同步，而类锁是用来控制静态方法（或者静态变量互斥体）之间的同步的。**

类锁只是一个概念上的东西，并非真实存在的，他只是用来帮助咱们理解锁定实例方法和静态方法的区别的。
java类可能会有不少对象，可是只有一个Class(字节码)对象，也就是说类的不一样实例之间共享该类的Class对象。**Class对象其实也仅仅是1个java对象，只不过有点特殊而已。**
因为每一个java对象都有1个互斥锁，而类的静态方法是须要Class对象。**因此所谓的类锁，只不过是Class对象的锁而已。**
**获取类的Class对象的方法有好几种，最简单的是[类名.class]的方式**。